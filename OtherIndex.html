<!DOCTYPE html>
<html lang="en">
<!-- [Previous head section and styles remain the same] -->
<head>
    <meta charset="UTF-8">
    <title>Image Voronoi Filter</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .image-inputs {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        #imageUrl {
            flex: 1;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #fff;
        }
        #imageUrl::placeholder {
            color: #888;
        }
        .or-divider {
            color: #888;
            font-weight: 500;
        }
        canvas {
            max-width: 800px;
            width: 100%;
            height: auto;
            background: #2d2d2d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        label {
            font-weight: 500;
            color: #fff;
        }
        input[type="file"] {
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #fff;
        }
        input[type="range"] {
            width: 200px;
            accent-color: #4a90e2;
        }
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover {
            background: #357abd;
        }
        .button-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .download-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .download-btn:hover {
            background: #218838;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #2d2d2d;
            color: #fff;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
            position: relative;
        }
        .close-button {
            position: absolute;
            right: 20px;
            top: 10px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #888;
        }
        .close-button:hover {
            color: #fff;
        }
        .error-details {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #444;
        }
        .error-details h3 {
            color: #888;
            margin-bottom: 10px;
        }
        .error-details ul {
            padding-left: 20px;
            color: #ccc;
        }
        .error-details li {
            margin-bottom: 8px;
        }
        .privacy-note {
            background: #2d2d2d;
            border-left: 4px solid #4a90e2;
            padding: 10px 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #888;
        }
        .privacy-note p {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .progress-container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress {
            width: 0%;
            height: 100%;
            background-color: #4a90e2;
            transition: width 0.3s ease;
        }

        #progressText {
            color: #666;
            font-size: 0.9em;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .logo {
            height: 50px;  /* Much smaller size */
            width: auto;
        }

        .logo-link {
            display: flex;  /* Ensures proper alignment */
            align-items: center;
        }

        .logo-link:hover {
            opacity: 0.8;  /* Subtle hover effect */
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .slider-container label {
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
        }

        .slider-container input[type="range"] {
            width: 200px;
        }

        .slider-container span {
            min-width: 45px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="https://innerscene.com" target="_blank" class="logo-link">
                <img src="logo.webp" alt="InnerScene Logo" class="logo">
            </a>
            <h1>Image Voronoi Filter</h1>
        </div>
        <div class="privacy-note">
            <p>ðŸ”’ All processing is done locally in your browser. No images are uploaded to any servers.</p>
        </div>
        <div class="controls">
            <div class="image-inputs">
                <input 
                    type="text" 
                    id="imageUrl" 
                    placeholder="Enter image URL"
                    value="sky.webp"
                >
                <span class="or-divider">OR</span>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            <div class="slider-container">
                <label>Number of Points: <input type="range" id="pointCount" min="200" max="20000" value="2000"><span id="pointCountDisplay">2000</span></label>
                <label>Smoothness: <input type="range" id="sampleSize" min="1" max="9" step="2" value="7"><span id="sampleSizeDisplay">7x7</span></label>
                <label>Line Thickness: <input type="range" id="lineThickness" min="0" max="7" step="1" value="1"><span id="lineThicknessDisplay">1px</span></label>
                <div class="button-container">
                    <button id="process">Process Image</button>
                    <button id="download" class="download-btn">Download Image</button>
                </div>
            </div>
        </div>
        <canvas id="canvas"></canvas>
    </div>

    <div id="errorModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Error Loading Image</h2>
            <p id="errorMessage"></p>
            <div class="error-details">
                <h3>Common Solutions:</h3>
                <ul>
                    <li>Try uploading the image directly instead of using a URL</li>
                    <li>Use an image from a site that allows cross-origin requests</li>
                    <li>Try a different image URL</li>
                </ul>
            </div>
        </div>
    </div>

<script>
// [Previous Point and Triangle classes remain exactly the same]
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    equals(other) {
        return Math.abs(this.x - other.x) < 0.000001 && 
               Math.abs(this.y - other.y) < 0.000001;
    }
}

class Triangle {
    constructor(p1, p2, p3) {
        this.points = [p1, p2, p3];
        this.edges = [
            [p1, p2],
            [p2, p3],
            [p3, p1]
        ];
        this.calculateCircumcenter();
    }

    calculateCircumcenter() {
        const [p1, p2, p3] = this.points;
        const D = 2 * (p1.x * (p2.y - p3.y) + 
                      p2.x * (p3.y - p1.y) + 
                      p3.x * (p1.y - p2.y));
        
        const Ux = ((p1.x * p1.x + p1.y * p1.y) * (p2.y - p3.y) +
                   (p2.x * p2.x + p2.y * p2.y) * (p3.y - p1.y) +
                   (p3.x * p3.x + p3.y * p3.y) * (p1.y - p2.y)) / D;
        
        const Uy = ((p1.x * p1.x + p1.y * p1.y) * (p3.x - p2.x) +
                   (p2.x * p2.x + p2.y * p2.y) * (p1.x - p3.x) +
                   (p3.x * p3.x + p3.y * p3.y) * (p2.x - p1.x)) / D;

        this.circumcenter = new Point(Ux, Uy);
        
        this.radiusSquared = (p1.x - Ux) * (p1.x - Ux) + 
                           (p1.y - Uy) * (p1.y - Uy);
    }

    containsPoint(point) {
        const dx = point.x - this.circumcenter.x;
        const dy = point.y - this.circumcenter.y;
        const distSquared = dx * dx + dy * dy;
        return distSquared <= this.radiusSquared * (1 + 0.000001);
    }
}

class VoronoiDiagram {
    constructor(width, height, points) {
        this.width = width;
        this.height = height;
        this.points = points;
        this.triangles = [];
        this.cells = new Map();
    }

    async generate() {
        // Generate triangulation
        await this.generateTriangulation();
        // Generate Voronoi cells
        await this.generateVoronoiCells();
        return this;
    }

    async generateTriangulation() {
        // Break up triangulation into chunks
        return new Promise(resolve => {
            setTimeout(() => {
                // Add super-triangle
                const margin = Math.max(this.width, this.height) * 2;
                const p1 = new Point(-margin, -margin);
                const p2 = new Point(this.width + margin, -margin);
                const p3 = new Point(this.width/2, this.height + margin);
                
                this.triangles = [new Triangle(p1, p2, p3)];

                // Add points one by one
                for (const point of this.points) {
                    const badTriangles = [];
                    
                    // Find all triangles where point lies in their circumcircle
                    for (const triangle of this.triangles) {
                        if (triangle.containsPoint(point)) {
                            badTriangles.push(triangle);
                        }
                    }
                    
                    // Find boundary of the polygonal hole
                    const boundary = [];
                    for (const triangle of badTriangles) {
                        for (const edge of triangle.edges) {
                            let isShared = false;
                            for (const otherTriangle of badTriangles) {
                                if (triangle === otherTriangle) continue;
                                
                                for (const otherEdge of otherTriangle.edges) {
                                    if ((edge[0].equals(otherEdge[0]) && edge[1].equals(otherEdge[1])) ||
                                        (edge[0].equals(otherEdge[1]) && edge[1].equals(otherEdge[0]))) {
                                        isShared = true;
                                        break;
                                    }
                                }
                                if (isShared) break;
                            }
                            if (!isShared) {
                                boundary.push(edge);
                            }
                        }
                    }
                    
                    // Remove bad triangles
                    this.triangles = this.triangles.filter(t => !badTriangles.includes(t));
                    
                    // Create new triangles from point and boundary edges
                    for (const edge of boundary) {
                        this.triangles.push(new Triangle(edge[0], edge[1], point));
                    }
                }

                // Remove triangles that share vertices with super-triangle
                this.triangles = this.triangles.filter(triangle => {
                    return !triangle.points.some(p => 
                        p === p1 || p === p2 || p === p3
                    );
                });
                resolve();
            }, 0);
        });
    }

    async generateVoronoiCells() {
        // Break up cell generation into chunks
        return new Promise(resolve => {
            setTimeout(() => {
                // Initialize cells for each point
                for (const point of this.points) {
                    this.cells.set(point, []);
                }

                // For each triangle, add its circumcenter to the cells of its vertices
                for (const triangle of this.triangles) {
                    for (const point of triangle.points) {
                        const cell = this.cells.get(point);
                        if (cell) {
                            cell.push(triangle.circumcenter);
                        }
                    }
                }

                // Sort points in each cell clockwise
                for (const [point, cell] of this.cells) {
                    this.sortPointsClockwise(cell, point);
                }
                resolve();
            }, 0);
        });
    }

    sortPointsClockwise(points, center) {
        points.sort((a, b) => {
            const angleA = Math.atan2(a.y - center.y, a.x - center.x);
            const angleB = Math.atan2(b.y - center.y, b.x - center.x);
            return angleA - angleB;
        });
    }
}

function calculateCentroid(polygon, width, height) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    
    // Find min and max coordinates
    for (const point of polygon) {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
    }
    
    // Calculate middle point
    let x = (minX + maxX) / 2;
    let y = (minY + maxY) / 2;
    
    // Ensure centroid is within image bounds
    x = Math.max(0, Math.min(width - 1, x));
    y = Math.max(0, Math.min(height - 1, y));
    
    return { x, y };
}

function getAverageColorAtPoint(ctx, centerX, centerY) {
    // Get sample size from slider (will be odd number 1-9)
    const sampleSize = parseInt(sampleSizeInput.value);
    const halfSize = Math.floor(sampleSize / 2);
    
    // Get exact pixel coordinates
    const x = Math.floor(centerX);
    const y = Math.floor(centerY);
    
    // Ensure we don't sample outside the image bounds
    const startX = Math.max(0, x - halfSize);
    const startY = Math.max(0, y - halfSize);
    const endX = Math.min(ctx.canvas.width, x + halfSize + 1);
    const endY = Math.min(ctx.canvas.height, y + halfSize + 1);
    
    const imageData = ctx.getImageData(startX, startY, 
                                     endX - startX, 
                                     endY - startY);
    const data = imageData.data;
    
    let r = 0, g = 0, b = 0, count = 0;
    
    for (let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i + 1];
        b += data[i + 2];
        count++;
    }
    
    if (count === 0) return { r: 0, g: 0, b: 0 };
    
    // Add occasional debug logging
    if (Math.random() < 0.01) {  // Log 1% of samples
        console.log(`Sampling at (${x}, ${y}), size: ${sampleSize}x${sampleSize}, color: RGB(${Math.round(r/count)}, ${Math.round(g/count)}, ${Math.round(b/count)})`);
    }
    
    return {
        r: Math.round(r / count),
        g: Math.round(g / count),
        b: Math.round(b / count)
    };
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const imageInput = document.getElementById('imageInput');
const pointCountInput = document.getElementById('pointCount');
const processButton = document.getElementById('process');

let image = null;
let currentImageUrl = '';
let originalImage = null;  // Store the unmodified original image

imageInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            // Store the original image
            originalImage = img;
            
            // Set up canvas
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            image = img;
            currentImageUrl = '';  // Clear the URL since we're using a file
            document.getElementById('imageUrl').value = ''; // Clear the URL input field
        };
        img.src = event.target.result;
    };
    
    reader.readAsDataURL(file);
});

function showError(message) {
    const modal = document.getElementById('errorModal');
    const errorMessage = document.getElementById('errorMessage');
    errorMessage.textContent = message;
    modal.style.display = 'block';
}

// Add modal close functionality
document.querySelector('.close-button').addEventListener('click', () => {
    document.getElementById('errorModal').style.display = 'none';
});

// Close modal when clicking outside
window.addEventListener('click', (event) => {
    const modal = document.getElementById('errorModal');
    if (event.target === modal) {
        modal.style.display = 'none';
    }
});

function loadImageFromUrl(url) {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    currentImageUrl = url;
    
    img.onload = () => {
        // Store the original image
        originalImage = img;
        
        // Set up canvas
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        image = img;

        // Automatically process the initial image
        const pointCount = parseInt(pointCountInput.value);
        processImage(pointCount);
    };
    
    img.onerror = (e) => {
        console.error('Error loading image:', e);
        showError(
            "Failed to load the image. This might be because: \n" +
            "â€¢ The URL is invalid\n" +
            "â€¢ The server is not responding\n" +
            "â€¢ The image doesn't exist\n" +
            "â€¢ The server doesn't allow access to the image"
        );
        currentImageUrl = '';
        image = null;
        originalImage = null;
    };
    
    img.src = url;
}

async function processImage(pointCount) {
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas and redraw original image
    ctx.clearRect(0, 0, width, height);
    ctx.drawImage(originalImage, 0, 0);
    
    // Store current state for processing
    const originalCanvas = document.createElement('canvas');
    const originalCtx = originalCanvas.getContext('2d');
    originalCanvas.width = width;
    originalCanvas.height = height;
    originalCtx.drawImage(originalImage, 0, 0);
    
    const points = generatePoints(pointCount, width, height);
    const voronoi = new VoronoiDiagram(width, height, points);
    await voronoi.generate();
    
    ctx.clearRect(0, 0, width, height);
    
    // Process cells in chunks
    const cells = Array.from(voronoi.cells.entries());
    const totalCells = cells.length;
    const chunkSize = Math.max(1, Math.floor(totalCells / 100));
    let processed = 0;

    return new Promise(resolve => {
        function processChunk() {
            const start = processed;
            const end = Math.min(processed + chunkSize, totalCells);
            
            // Get current line thickness
            const lineThickness = parseInt(lineThicknessInput.value);
            ctx.lineWidth = lineThickness;
            
            for (let i = start; i < end; i++) {
                const [point, cell] = cells[i];
                if (cell.length < 3) continue;
                
                const centroid = calculateCentroid(cell, width, height);
                const color = getAverageColorAtPoint(originalCtx, centroid.x, centroid.y);
                
                // Fill polygon
                ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
                ctx.beginPath();
                ctx.moveTo(cell[0].x, cell[0].y);
                
                for (let j = 1; j < cell.length; j++) {
                    ctx.lineTo(cell[j].x, cell[j].y);
                }
                
                ctx.closePath();
                ctx.fill();
                
                // Draw polygon outline if thickness > 0
                if (lineThickness > 0) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';  // Semi-transparent black
                    ctx.stroke();
                }
            }
            
            processed = end;
            
            if (processed < totalCells) {
                setTimeout(processChunk, 0);
            } else {
                resolve();
            }
        }
        
        // Start processing chunks
        setTimeout(processChunk, 0);
    });
}

// Make sure this runs after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const processButton = document.getElementById('process');
    if (!processButton) {
        console.error('Process button not found!');
        return;
    }

    processButton.addEventListener('click', async () => {
        console.log('Process button clicked');  // Immediate feedback
        
        const newUrl = document.getElementById('imageUrl').value;
        if (newUrl !== currentImageUrl) {
            console.log('Loading new URL:', newUrl);
            loadImageFromUrl(newUrl);
            return;
        }
        
        if (!originalImage || !originalImage.complete) {
            console.log('No image loaded or image not complete');
            return;
        }
        
        try {
            const pointCount = parseInt(pointCountInput.value);
            await processImage(pointCount);
        } catch (error) {
            console.error('Error during processing:', error);
            showError('An error occurred while processing the image');
        }
    });

    // Load and process default
    const defaultUrl = document.getElementById('imageUrl').value;
    console.log('Loading default image:', defaultUrl);
    loadImageFromUrl(defaultUrl);
});

pointCountInput.addEventListener('input', (e) => {
    document.getElementById('pointCountDisplay').textContent = e.target.value;
});

const downloadBtn = document.getElementById('download');

// Update the download button handler with error catching
downloadBtn.addEventListener('click', () => {
    try {
        // Create a temporary link
        const link = document.createElement('a');
        link.download = 'voronoi-art.png';
        link.href = canvas.toDataURL('image/png');
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } catch (e) {
        console.error('Download error:', e);
        showError(
            "Unable to download the image. This might be due to CORS restrictions. " +
            "Try taking a screenshot instead, or use a different image source."
        );
    }
});

// Add with other global variables
const sampleSizeInput = document.getElementById('sampleSize');

// Add event listener for sample size display
sampleSizeInput.addEventListener('input', (e) => {
    const size = e.target.value;
    document.getElementById('sampleSizeDisplay').textContent = `${size}x${size}`;
});

const lineThicknessInput = document.getElementById('lineThickness');

// Add event listener for line thickness display
lineThicknessInput.addEventListener('input', (e) => {
    const thickness = e.target.value;
    document.getElementById('lineThicknessDisplay').textContent = `${thickness}px`;
});

function generatePoints(count, width, height) {
    const points = [];
    
    // Add border points
    points.push(new Point(0, 0));
    points.push(new Point(width, 0));
    points.push(new Point(0, height));
    points.push(new Point(width, height));
    points.push(new Point(width/2, 0));
    points.push(new Point(width/2, height));
    points.push(new Point(0, height/2));
    points.push(new Point(width, height/2));
    
    // Add random points
    for (let i = 0; i < count - 8; i++) {
        points.push(new Point(
            Math.random() * width,
            Math.random() * height
        ));
    }
    
    return points;
}
</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"74425f3df6594d2ea68d145b962d6c9c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
